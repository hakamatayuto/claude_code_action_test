"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/taskUtils.ts":
/*!**************************!*\
  !*** ./lib/taskUtils.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   generateDateRange: function() { return /* binding */ generateDateRange; },\n/* harmony export */   loadTasks: function() { return /* binding */ loadTasks; },\n/* harmony export */   processTasks: function() { return /* binding */ processTasks; }\n/* harmony export */ });\nasync function loadTasks() {\n    try {\n        console.log(\"Fetching tasks from /api/tasks...\");\n        const response = await fetch(\"/api/tasks\");\n        console.log(\"Response status:\", response.status);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"API error response:\", errorText);\n            throw new Error(\"HTTP error! status: \".concat(response.status, \", message: \").concat(errorText));\n        }\n        const tasks = await response.json();\n        console.log(\"Loaded tasks:\", tasks);\n        return tasks;\n    } catch (error) {\n        console.error(\"タスクの読み込みに失敗しました:\", error);\n        throw error // エラーを再スローして上位でキャッチ\n        ;\n    }\n}\nfunction processTasks(tasks) {\n    if (tasks.length === 0) {\n        const now = new Date();\n        return {\n            processedTasks: [],\n            startDate: now,\n            endDate: now,\n            totalDays: 0\n        };\n    }\n    const processedTasks = tasks.map((task)=>{\n        const startDate = new Date(task.開始日);\n        const endDate = new Date(task.終了日);\n        const duration = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;\n        return {\n            ...task,\n            startDate,\n            endDate,\n            duration,\n            startOffset: 0 // 後で計算\n        };\n    });\n    // 全体の開始日と終了日を計算\n    const allStartDates = processedTasks.map((task)=>task.startDate);\n    const allEndDates = processedTasks.map((task)=>task.endDate);\n    const projectStartDate = new Date(Math.min(...allStartDates.map((date)=>date.getTime())));\n    const projectEndDate = new Date(Math.max(...allEndDates.map((date)=>date.getTime())));\n    const totalDays = Math.ceil((projectEndDate.getTime() - projectStartDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;\n    // 各タスクの開始オフセットを計算\n    processedTasks.forEach((task)=>{\n        task.startOffset = Math.ceil((task.startDate.getTime() - projectStartDate.getTime()) / (1000 * 60 * 60 * 24));\n    });\n    return {\n        processedTasks,\n        startDate: projectStartDate,\n        endDate: projectEndDate,\n        totalDays\n    };\n}\nfunction formatDate(date) {\n    return date.toLocaleDateString(\"ja-JP\", {\n        month: \"short\",\n        day: \"numeric\"\n    });\n}\nfunction generateDateRange(startDate, totalDays) {\n    const dates = [];\n    for(let i = 0; i < totalDays; i++){\n        const date = new Date(startDate);\n        date.setDate(startDate.getDate() + i);\n        dates.push(date);\n    }\n    return dates;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi90YXNrVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW1CTyxlQUFlQTtJQUNwQixJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE1BQU1DLFdBQVcsTUFBTUMsTUFBTTtRQUM3QkgsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQkMsU0FBU0UsTUFBTTtRQUUvQyxJQUFJLENBQUNGLFNBQVNHLEVBQUUsRUFBRTtZQUNoQixNQUFNQyxZQUFZLE1BQU1KLFNBQVNLLElBQUk7WUFDckNQLFFBQVFRLEtBQUssQ0FBQyx1QkFBdUJGO1lBQ3JDLE1BQU0sSUFBSUcsTUFBTSx1QkFBb0RILE9BQTdCSixTQUFTRSxNQUFNLEVBQUMsZUFBdUIsT0FBVkU7UUFDdEU7UUFFQSxNQUFNSSxRQUFRLE1BQU1SLFNBQVNTLElBQUk7UUFDakNYLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJTO1FBQzdCLE9BQU9BO0lBQ1QsRUFBRSxPQUFPRixPQUFPO1FBQ2RSLFFBQVFRLEtBQUssQ0FBQyxvQkFBb0JBO1FBQ2xDLE1BQU1BLE1BQU0sb0JBQW9COztJQUNsQztBQUNGO0FBRU8sU0FBU0ksYUFBYUYsS0FBYTtJQU14QyxJQUFJQSxNQUFNRyxNQUFNLEtBQUssR0FBRztRQUN0QixNQUFNQyxNQUFNLElBQUlDO1FBQ2hCLE9BQU87WUFDTEMsZ0JBQWdCLEVBQUU7WUFDbEJDLFdBQVdIO1lBQ1hJLFNBQVNKO1lBQ1RLLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTUgsaUJBQWtDTixNQUFNVSxHQUFHLENBQUNDLENBQUFBO1FBQ2hELE1BQU1KLFlBQVksSUFBSUYsS0FBS00sS0FBS0MsR0FBRztRQUNuQyxNQUFNSixVQUFVLElBQUlILEtBQUtNLEtBQUtFLEdBQUc7UUFDakMsTUFBTUMsV0FBV0MsS0FBS0MsSUFBSSxDQUFDLENBQUNSLFFBQVFTLE9BQU8sS0FBS1YsVUFBVVUsT0FBTyxFQUFDLElBQU0sUUFBTyxLQUFLLEtBQUssRUFBQyxLQUFNO1FBRWhHLE9BQU87WUFDTCxHQUFHTixJQUFJO1lBQ1BKO1lBQ0FDO1lBQ0FNO1lBQ0FJLGFBQWEsRUFBRSxPQUFPO1FBQ3hCO0lBQ0Y7SUFFQSxnQkFBZ0I7SUFDaEIsTUFBTUMsZ0JBQWdCYixlQUFlSSxHQUFHLENBQUNDLENBQUFBLE9BQVFBLEtBQUtKLFNBQVM7SUFDL0QsTUFBTWEsY0FBY2QsZUFBZUksR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLSCxPQUFPO0lBRTNELE1BQU1hLG1CQUFtQixJQUFJaEIsS0FBS1UsS0FBS08sR0FBRyxJQUFJSCxjQUFjVCxHQUFHLENBQUNhLENBQUFBLE9BQVFBLEtBQUtOLE9BQU87SUFDcEYsTUFBTU8saUJBQWlCLElBQUluQixLQUFLVSxLQUFLVSxHQUFHLElBQUlMLFlBQVlWLEdBQUcsQ0FBQ2EsQ0FBQUEsT0FBUUEsS0FBS04sT0FBTztJQUVoRixNQUFNUixZQUFZTSxLQUFLQyxJQUFJLENBQUMsQ0FBQ1EsZUFBZVAsT0FBTyxLQUFLSSxpQkFBaUJKLE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUMsS0FBTTtJQUUvRyxrQkFBa0I7SUFDbEJYLGVBQWVvQixPQUFPLENBQUNmLENBQUFBO1FBQ3JCQSxLQUFLTyxXQUFXLEdBQUdILEtBQUtDLElBQUksQ0FBQyxDQUFDTCxLQUFLSixTQUFTLENBQUNVLE9BQU8sS0FBS0ksaUJBQWlCSixPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDO0lBQzVHO0lBRUEsT0FBTztRQUNMWDtRQUNBQyxXQUFXYztRQUNYYixTQUFTZ0I7UUFDVGY7SUFDRjtBQUNGO0FBRU8sU0FBU2tCLFdBQVdKLElBQVU7SUFDbkMsT0FBT0EsS0FBS0ssa0JBQWtCLENBQUMsU0FBUztRQUN0Q0MsT0FBTztRQUNQQyxLQUFLO0lBQ1A7QUFDRjtBQUVPLFNBQVNDLGtCQUFrQnhCLFNBQWUsRUFBRUUsU0FBaUI7SUFDbEUsTUFBTXVCLFFBQWdCLEVBQUU7SUFDeEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl4QixXQUFXd0IsSUFBSztRQUNsQyxNQUFNVixPQUFPLElBQUlsQixLQUFLRTtRQUN0QmdCLEtBQUtXLE9BQU8sQ0FBQzNCLFVBQVU0QixPQUFPLEtBQUtGO1FBQ25DRCxNQUFNSSxJQUFJLENBQUNiO0lBQ2I7SUFDQSxPQUFPUztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi90YXNrVXRpbHMudHM/ZGM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFRhc2sge1xuICDjgr/jgrnjgq/lkI06IHN0cmluZ1xuICDmi4XlvZPogIU6IHN0cmluZ1xuICDplovlp4vml6U6IHN0cmluZ1xuICDntYLkuobml6U6IHN0cmluZ1xuICDoqbPntLA6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tEYXRhIHtcbiAgdGFza3M6IFRhc2tbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NlZFRhc2sgZXh0ZW5kcyBUYXNrIHtcbiAgc3RhcnREYXRlOiBEYXRlXG4gIGVuZERhdGU6IERhdGVcbiAgZHVyYXRpb246IG51bWJlclxuICBzdGFydE9mZnNldDogbnVtYmVyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkVGFza3MoKTogUHJvbWlzZTxUYXNrW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgdGFza3MgZnJvbSAvYXBpL3Rhc2tzLi4uJylcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Rhc2tzJylcbiAgICBjb25zb2xlLmxvZygnUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cylcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBlcnJvciByZXNwb25zZTonLCBlcnJvclRleHQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9LCBtZXNzYWdlOiAke2Vycm9yVGV4dH1gKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB0YXNrcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgdGFza3M6JywgdGFza3MpXG4gICAgcmV0dXJuIHRhc2tzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign44K/44K544Kv44Gu6Kqt44G/6L6844G/44Gr5aSx5pWX44GX44G+44GX44GfOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yIC8vIOOCqOODqeODvOOCkuWGjeOCueODreODvOOBl+OBpuS4iuS9jeOBp+OCreODo+ODg+ODgVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVGFza3ModGFza3M6IFRhc2tbXSk6IHtcbiAgcHJvY2Vzc2VkVGFza3M6IFByb2Nlc3NlZFRhc2tbXVxuICBzdGFydERhdGU6IERhdGVcbiAgZW5kRGF0ZTogRGF0ZVxuICB0b3RhbERheXM6IG51bWJlclxufSB7XG4gIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2Nlc3NlZFRhc2tzOiBbXSxcbiAgICAgIHN0YXJ0RGF0ZTogbm93LFxuICAgICAgZW5kRGF0ZTogbm93LFxuICAgICAgdG90YWxEYXlzOiAwXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJvY2Vzc2VkVGFza3M6IFByb2Nlc3NlZFRhc2tbXSA9IHRhc2tzLm1hcCh0YXNrID0+IHtcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSh0YXNrLumWi+Wni+aXpSlcbiAgICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUodGFzay7ntYLkuobml6UpXG4gICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLmNlaWwoKGVuZERhdGUuZ2V0VGltZSgpIC0gc3RhcnREYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgMVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXNrLFxuICAgICAgc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgc3RhcnRPZmZzZXQ6IDAgLy8g5b6M44Gn6KiI566XXG4gICAgfVxuICB9KVxuXG4gIC8vIOWFqOS9k+OBrumWi+Wni+aXpeOBqOe1guS6huaXpeOCkuioiOeul1xuICBjb25zdCBhbGxTdGFydERhdGVzID0gcHJvY2Vzc2VkVGFza3MubWFwKHRhc2sgPT4gdGFzay5zdGFydERhdGUpXG4gIGNvbnN0IGFsbEVuZERhdGVzID0gcHJvY2Vzc2VkVGFza3MubWFwKHRhc2sgPT4gdGFzay5lbmREYXRlKVxuICBcbiAgY29uc3QgcHJvamVjdFN0YXJ0RGF0ZSA9IG5ldyBEYXRlKE1hdGgubWluKC4uLmFsbFN0YXJ0RGF0ZXMubWFwKGRhdGUgPT4gZGF0ZS5nZXRUaW1lKCkpKSlcbiAgY29uc3QgcHJvamVjdEVuZERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heCguLi5hbGxFbmREYXRlcy5tYXAoZGF0ZSA9PiBkYXRlLmdldFRpbWUoKSkpKVxuICBcbiAgY29uc3QgdG90YWxEYXlzID0gTWF0aC5jZWlsKChwcm9qZWN0RW5kRGF0ZS5nZXRUaW1lKCkgLSBwcm9qZWN0U3RhcnREYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgMVxuXG4gIC8vIOWQhOOCv+OCueOCr+OBrumWi+Wni+OCquODleOCu+ODg+ODiOOCkuioiOeul1xuICBwcm9jZXNzZWRUYXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgIHRhc2suc3RhcnRPZmZzZXQgPSBNYXRoLmNlaWwoKHRhc2suc3RhcnREYXRlLmdldFRpbWUoKSAtIHByb2plY3RTdGFydERhdGUuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSlcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NlZFRhc2tzLFxuICAgIHN0YXJ0RGF0ZTogcHJvamVjdFN0YXJ0RGF0ZSxcbiAgICBlbmREYXRlOiBwcm9qZWN0RW5kRGF0ZSxcbiAgICB0b3RhbERheXNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdqYS1KUCcsIHtcbiAgICBtb250aDogJ3Nob3J0JyxcbiAgICBkYXk6ICdudW1lcmljJ1xuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEYXRlUmFuZ2Uoc3RhcnREYXRlOiBEYXRlLCB0b3RhbERheXM6IG51bWJlcik6IERhdGVbXSB7XG4gIGNvbnN0IGRhdGVzOiBEYXRlW10gPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsRGF5czsgaSsrKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSlcbiAgICBkYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSArIGkpXG4gICAgZGF0ZXMucHVzaChkYXRlKVxuICB9XG4gIHJldHVybiBkYXRlc1xufSJdLCJuYW1lcyI6WyJsb2FkVGFza3MiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsInN0YXR1cyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwiRXJyb3IiLCJ0YXNrcyIsImpzb24iLCJwcm9jZXNzVGFza3MiLCJsZW5ndGgiLCJub3ciLCJEYXRlIiwicHJvY2Vzc2VkVGFza3MiLCJzdGFydERhdGUiLCJlbmREYXRlIiwidG90YWxEYXlzIiwibWFwIiwidGFzayIsIumWi+Wni+aXpSIsIue1guS6huaXpSIsImR1cmF0aW9uIiwiTWF0aCIsImNlaWwiLCJnZXRUaW1lIiwic3RhcnRPZmZzZXQiLCJhbGxTdGFydERhdGVzIiwiYWxsRW5kRGF0ZXMiLCJwcm9qZWN0U3RhcnREYXRlIiwibWluIiwiZGF0ZSIsInByb2plY3RFbmREYXRlIiwibWF4IiwiZm9yRWFjaCIsImZvcm1hdERhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJtb250aCIsImRheSIsImdlbmVyYXRlRGF0ZVJhbmdlIiwiZGF0ZXMiLCJpIiwic2V0RGF0ZSIsImdldERhdGUiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/taskUtils.ts\n"));

/***/ })

});